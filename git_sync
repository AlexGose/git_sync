#!/bin/bash

error() {
  echo "Error: $1" >&2
  exit 1
}

usage() {
  local usage_string
  usage_string="Usage: git_sync OPTIONS
  OPTIONS
  -h                    Display this help message
  -f                    Fetch changes in the remote Git repository origin
  -p                    Pull changes from the remote Git repository origin
  -s                    Stage any unstaged changes
  -d PATH               Path to the directory of the Git repository"
  echo "${usage_string}"
}

# Execute a Git command in the given repository
# Usage: run_git_command <command> <path to repository>
# Inputs: 
#     <command> - Git command ("fetch", "pull", "ls-untracked", etc.)
#     <path to repository> - path to the local Git repository
# Modifies the local Git repository located at <path to repository>.
# When <command> is
#   fetch - the command "git fetch" will be run.
#   pull  - the command "git pull" will be run.
#   ls-untracked  - the command will list all untracked, but not
#           ignored, files.
#   stage - the command "git add ." will be run.
#   diff-state - the command "git diff --numstat" will be run.
run_git_command() {
  if (( $# < 2 )); then
    error "Too few arguments: $@"
  fi
  
  local run_flag
  run_flag="false"
  local git_command
  case "$1" in
    fetch)
      run_flag="true"
      git_command="fetch"
      ;;
    pull)
      run_flag="true"
      git_command="pull"
      ;;
    list-untracked)
      run_flag="true"
      git_command=("ls-files" "-o" "--exclude-standard")
      ;;
    diff-numstat)
      run_flag="true"
      git_command=("diff" "--numstat")
      ;;
    stage)
      run_flag="true"
      git_command=("add" ".")
      ;;
    *) error "Unsupported Git command: $1" ;;
  esac
  
  if [[ "${run_flag}" == "true" ]]; then
    if ! git -C "$2" "${git_command[@]}"; then
      error "Unable to execute "${git_command[@]}" in directory: $2"
    fi
  else
    error "Unsupported Git command: $1"
  fi
}

main() {
  if (( $# == 0 )); then
      usage
      error "git_sync requires at least one option"
  fi
  
  local fetch_flag
  fetch_flag="false"
  local pull_flag
  pull_flag="false"
  local stage_flag
  stage_flag="false"
  local repo_dir
  repo_dir="$(pwd)"
  
  while getopts :hfpsd: opt; do
    case "${opt}" in
      h) usage; exit 0 ;;
      f) fetch_flag="true" ;;
      p) pull_flag="true" ;;
      s) stage_flag="true" ;;
      d) repo_dir="${OPTARG}" ;;
      *) error "Unkown option: ${opt}" ;;
    esac
  done
  
  if [[ "${fetch_flag}" == "true" ]]; then
    run_git_command fetch "${repo_dir}"
  fi
  if [[ "${pull_flag}" == "true" ]]; then
    run_git_command pull "${repo_dir}"
  fi
  if [[ "${stage_flag}" == "true" ]]; then
    local untracked_files
    untracked_files="$(run_git_command list-untracked "${repo_dir}")"
    #echo "untracked files = ${untracked_files}"
    
    local unstaged_changes
    unstaged_changes="$(run_git_command diff-numstat "${repo_dir}")"
    #echo "unstaged changes=${unstaged_changes}"
    
    # only change timestamp of .git/index if necessary
    if [[ -n "${untracked_files}" ]] || [[ -n "${unstaged_changes}" ]]; then
      run_git_command stage "${repo_dir}"
    fi
  fi
}

main "$@"
